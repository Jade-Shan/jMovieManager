/**
 * Copyright (c) 2010-2015 Bryan Beck.
 * All rights reserved.
 * 
 * This project is licensed under LGPL v2.1.
 * See jMovieManager-license.txt for details.
 * 
 */
package jMovieManager.swing.gui.splitpane.left;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Frame;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.dnd.DropTarget;
import java.awt.dnd.DropTargetAdapter;
import java.awt.dnd.DropTargetDropEvent;
import java.awt.event.KeyEvent;
import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.Observable;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.text.Position;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.MutableTreeNode;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
import javax.swing.tree.TreeSelectionModel;
import jmm.data.Episode;
import jmm.data.Season;
import jmm.data.Serie;
import jmm.data.collection.SerieCollection;
import jmm.data.DataManager;
import jmm.data.collection.CollectionManager;
import jMovieManager.swing.gui.ImportDirectoryGUI;
import jMovieManager.swing.gui.MovieManagerGUI;
import jMovieManager.swing.gui.UIInterface;
import jMovieManager.swing.gui.createmedia.CreateSerieGUI;
import jMovieManager.swing.gui.other.MyTreeCellRenderer;
import jMovieManager.swing.gui.splitpane.right.EpisodeDetailGUI;
import jMovieManager.swing.gui.splitpane.right.SerieDetailGUI;
import java.awt.Cursor;
import javax.swing.JOptionPane;
import jmm.utils.OperatingSystem;
import org.hibernate.annotations.common.util.impl.LoggerFactory;
import org.jboss.logging.Logger;

/**
 * Serie Tree Panel for all Tab GUIs
 * 
 * @author Bryan Beck
 * @since 28.08.2012
 */
public class SerieTabGUI extends AbstractTabGUI implements UIInterface{
    /** Logger. */
    private static final Logger LOG = LoggerFactory.logger(SerieTabGUI.class);
    
    //TreeModel für Serien
    private DefaultTreeModel seriesTreeModel;
    //Rootknoten
    private DefaultMutableTreeNode seriesRootTreeNode;
        
    //required to dynamically update watched movie state
    private Object currentMouseOver = new Object();
    private Object previousMouseOver = new Object();
    private TreeNode previousTreeNode;
    private Boolean previousWatched;
    
    /**
     * Creates new form SerieTabGUI
     * @param collection the SerieCollection related to this tab
     * @param searchTab if true, the tab is not editable
     */
    public SerieTabGUI(SerieCollection collection, boolean searchTab) {
        super(collection, MediaType.SERIE, searchTab);
        seriesRootTreeNode = new DefaultMutableTreeNode("Serien");
        seriesTreeModel = new DefaultTreeModel(seriesRootTreeNode);
        
        initComponents();
                
        if(useCustomLAF){
            this.changeUI();
        }
        //Benötigt, damit das UI seine Size selbst managed und die Scrollbars für den Tree richtig funktionieren
        jTree1.setPreferredSize(null);
        jTree1.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
        //jTree1.setShowsRootHandles(true);

//        //File Drop für jListe, zum automatischen Import
        if(OperatingSystem.isWindowsPlatform()){
            initJListFileDropOnWindows();
        }  
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = super.getTabPanel();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTree1 = new javax.swing.JTree();

        setLayout(new javax.swing.BoxLayout(this, javax.swing.BoxLayout.LINE_AXIS));

        jPanel1.setPreferredSize(new java.awt.Dimension(260, 700));
        jPanel1.setLayout(new javax.swing.BoxLayout(jPanel1, javax.swing.BoxLayout.LINE_AXIS));

        jScrollPane2.setMinimumSize(new java.awt.Dimension(244, 0));
        jScrollPane2.setOpaque(false);
        jScrollPane2.setPreferredSize(new java.awt.Dimension(244, 678));

        jTree1.setModel(seriesTreeModel);
        jTree1.setCellRenderer(new MyTreeCellRenderer());
        jTree1.setMaximumSize(new java.awt.Dimension(0, 0));
        jTree1.setPreferredSize(new java.awt.Dimension(0, 0));
        jTree1.setRootVisible(false);
        jTree1.setShowsRootHandles(true);
        jTree1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jTree1MouseClicked(evt);
            }
        });
        jTree1.addTreeSelectionListener(new javax.swing.event.TreeSelectionListener() {
            public void valueChanged(javax.swing.event.TreeSelectionEvent evt) {
                jTree1ValueChanged(evt);
            }
        });
        jTree1.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                jTree1MouseMoved(evt);
            }
        });
        jTree1.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyTyped(java.awt.event.KeyEvent evt) {
                jTree1KeyTyped(evt);
            }
        });
        jScrollPane2.setViewportView(jTree1);

        jPanel1.add(jScrollPane2);

        add(jPanel1);
    }// </editor-fold>//GEN-END:initComponents

    /**
     * jTree1MouseClicked - Double Click Edit <br/>
     * Edits the current selected list value
     * @param evt the triggered event
     */
    private void jTree1MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jTree1MouseClicked
        //on doubleclick
        int x = evt.getX();
        TreePath selectionPath = this.getSelectionPath();
        if((evt.getClickCount() > 1) && (selectionPath != null)){
            this.createUpdateSelectedMediaFileDialog(MovieManagerGUI.getInstance());
        }
        else if((selectionPath != null) && (selectionPath.getPathCount() == 4) && (x > 60) && (x < 80)){ //16 px icon width
            //Determine if the watched icon was clicked
                Episode selMovie = (Episode)((DefaultMutableTreeNode)selectionPath.getLastPathComponent()).getUserObject();
                if(selMovie != null){
                    selMovie.setWatched(!previousWatched);
                    //Update specific list item
                    seriesTreeModel.reload((TreeNode)selectionPath.getLastPathComponent());
                    //reset watched state
                    previousWatched = selMovie.isWatched();
                }
                evt.consume();          
        } 
    }//GEN-LAST:event_jTree1MouseClicked

    /**
     * jTree1ValueChanged - Updates the displayed serie<br/>
     * Updates the displayed serie on the main GUI to the selected one
     * @param evt the triggered event
     */
    private void jTree1ValueChanged(javax.swing.event.TreeSelectionEvent evt) {//GEN-FIRST:event_jTree1ValueChanged
        //initialize center border element
        JPanel rightSplitPane = MovieManagerGUI.getInstance().getRightSplitPane();
        BorderLayout layout = (BorderLayout) rightSplitPane.getLayout();
        Component centerComponent = layout.getLayoutComponent(BorderLayout.CENTER);

        TreePath selectedPath = this.getSelectionPath();
        if(selectedPath != null){
            int pathCount = selectedPath.getPathCount();
            if(centerComponent != null){
                rightSplitPane.remove(centerComponent);
            }

            if(pathCount == 2){
                //Add and display SerieDetailGUI
                rightSplitPane.add(SerieDetailGUI.getInstance().getRootPanel(), BorderLayout.CENTER);
                Serie serie = (Serie)((DefaultMutableTreeNode)selectedPath.getLastPathComponent()).getUserObject();
                SerieDetailGUI.getInstance().updateSerieDetail(serie);
            }
            //                else if(pathCount == 3){
                //                    //StaffelPanel hinzufügen
                //                    //jPanel6.add(SeasonDetailGUI.getInstance().getSeasonDetailPanel(), BorderLayout.CENTER);
                //                }
            else if(pathCount == 4){
                //Add and display EpisodeDetailGUI
                rightSplitPane.add(EpisodeDetailGUI.getInstance().getRootPanel(), BorderLayout.CENTER);
//                Serie serie = (Serie)selectedPath.getPathComponent(1);
//                Season season = (Season)selectedPath.getPathComponent(2);
                Episode episode = (Episode)((DefaultMutableTreeNode)selectedPath.getPathComponent(3)).getUserObject();      
                EpisodeDetailGUI.getInstance().updateEpisodeDetail(episode);       
            }
            MovieManagerGUI.getInstance().updateEnabledGUIElements();
        }else{
            if((centerComponent != null) &&
                (centerComponent.equals(SerieDetailGUI.getInstance().getRootPanel()) ||
                    centerComponent.equals(EpisodeDetailGUI.getInstance().getRootPanel()))){
                rightSplitPane.remove(centerComponent);
            }
            //removeMovieInformation();
        }
        rightSplitPane.repaint();
    }//GEN-LAST:event_jTree1ValueChanged

    /**
     * jTree1KeyTyped - Delete selected Value <br/>
     * Checks if the delete button is pressed and deletes the selected value
     * @param evt the triggered event
     */
    private void jTree1KeyTyped(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTree1KeyTyped
        if((evt.getKeyChar() == KeyEvent.VK_DELETE) && (getSelectionPath() != null)){         
            int confirm = javax.swing.JOptionPane.showConfirmDialog(this,
                    bundle.getString("SerieTabGUI.confirmDelete.text"),
                    bundle.getString("SerieTabGUI.confirmDelete.headline"),
                    JOptionPane.YES_NO_OPTION,
                    JOptionPane.QUESTION_MESSAGE);      
            if(confirm == 0){
                this.removeSelectedValue();
            }
        }
    }//GEN-LAST:event_jTree1KeyTyped

    /**
     * jList1 - get item on mouse position<br/>
     * Determines the listitem on the mouse position
     * @param evt The triggered event
     */
    private void jTree1MouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jTree1MouseMoved
        TreePath path = jTree1.getClosestPathForLocation(evt.getX(), evt.getY());
        int x = evt.getX();
        if((path != null) && (path.getPathCount() == 4) && (x > 60) && (x < 80)){
                this.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
                currentMouseOver = ((DefaultMutableTreeNode)path.getLastPathComponent()).getUserObject();
                if(!previousMouseOver.equals(currentMouseOver)){
                    //restore icon of the previousMouseOver Label
                    if(previousMouseOver instanceof Episode){
                        ((Episode)previousMouseOver).setWatched(previousWatched);
                    }
                    previousWatched = ((Episode)currentMouseOver).isWatched();
                    ((Episode)currentMouseOver).setWatched(true);
                    //Update specific list item
//                    seriesTreeModel.nodeChanged((TreeNode)path.getLastPathComponent());
                    seriesTreeModel.reload((TreeNode)path.getLastPathComponent());
                    previousMouseOver = currentMouseOver;
                    previousTreeNode = (TreeNode)path.getLastPathComponent();
                }
        }else if(previousTreeNode != null){
            if(previousMouseOver instanceof Episode){
                ((Episode)previousMouseOver).setWatched(previousWatched);
                //Update specific list item
                seriesTreeModel.reload(previousTreeNode);
            }
            previousTreeNode = null;
            this.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
        }
    }//GEN-LAST:event_jTree1MouseMoved

    /**
     * @return the collection
     */
    @Override
    public SerieCollection getCollection() {
        return (SerieCollection)collection;
    }
    
   /**
    * Gibt den selektierten Baumpfad zurück
    * 
    * @return Der selektierte Pfad <br/> null, wenn kein Pfad selektiert wurde 
    */
   public TreePath getSelectionPath(){
       return jTree1.getSelectionPath();
   }
   
     /**
     * Creates a new dialog to edit a mediaFile.<br/>
     * The selected value will be edited.
     * 
     * @param parent the parent frame
     * 
     */  
    @Override
    public void createUpdateSelectedMediaFileDialog(Frame parent){
        TreePath selectionPath = this.getSelectionPath();   
        if((selectionPath != null) && (!collection.isSearchCollection())){
            if(selectionPath.getPathCount() == 2){
                //Edit Serie
                Serie serie = (Serie)((DefaultMutableTreeNode)selectionPath.getPathComponent(1)).getUserObject();
                CreateSerieGUI updateSerieGUI = new CreateSerieGUI(parent, true, serie, getCollection(), true);
                serie = updateSerieGUI.showGUI();
                if(serie != null){
                    this.updateSerieInGUI(serie);
                    SerieDetailGUI.getInstance().updateSerieDetail(serie);
                }                
            }
            else if(selectionPath.getPathCount() == 4){
                //Edit Episode
                Serie serie = (Serie)((DefaultMutableTreeNode)selectionPath.getPathComponent(1)).getUserObject();
                Episode episode = (Episode)((DefaultMutableTreeNode)selectionPath.getPathComponent(3)).getUserObject();
                CreateSerieGUI updateEpisode = new CreateSerieGUI(parent, true, serie, episode, (SerieCollection)collection, true);
                serie = updateEpisode.showGUI();
                if(serie != null){
                    this.updateSerieInGUI(serie);
    //                if(episode != null){
    //                    EpisodeDetailGUI.getInstance().updateEpisodeDetail(episode);
    //                }
                }
            }   
        }
    }   
   
    /**
    * @see Observer#update(java.util.Observable, java.lang.Object) 
    */
    @Override
    public void update(Observable o, Object arg) {
        super.update(o, arg);
        if(arg == null){
            //ordering has changed, full update
            updateTabValues();
        }
        else if(arg instanceof Serie){
            Serie serie = (Serie)arg;
            if(this.getTreePath(serie) == null){                    
                this.addSerieToGUI(serie);
            }else{
                this.removeLastNodeFromTree(this.getTreePath(serie));  
            }
        }
    }    

    /**
     * removes the selected serie or episode 
     * from the collection and the tree
     */
    @Override
    public void removeSelectedValue(){
        TreePath selectionPath = this.getSelectionPath();
        if((selectionPath != null) && (!collection.isSearchCollection())){
            if(selectionPath.getPathCount() == 2){
                //Remove Serie
                Serie serie = (Serie)((DefaultMutableTreeNode)selectionPath.getPathComponent(1)).getUserObject();
                DataManager.INSTANCE.removeSerie((SerieCollection)collection, serie.toString());
            }
            else if(selectionPath.getPathCount() == 3){
                //Remove Season
                Serie serie = (Serie)((DefaultMutableTreeNode)selectionPath.getPathComponent(1)).getUserObject();
                Season season = (Season)((DefaultMutableTreeNode)selectionPath.getPathComponent(2)).getUserObject();

                if(DataManager.INSTANCE.removeSeason(serie, season.getSeasonNumber()) != null){
                    //remove season fom GUI
                    this.removeLastNodeFromTree(this.getTreePath(season, serie));
                }
            }
            else if(selectionPath.getPathCount() == 4){
                //Remove Episode
                Serie serie = (Serie)((DefaultMutableTreeNode)selectionPath.getPathComponent(1)).getUserObject();
                Season season = (Season)((DefaultMutableTreeNode)selectionPath.getPathComponent(2)).getUserObject();
                Episode episode = (Episode)((DefaultMutableTreeNode)selectionPath.getPathComponent(3)).getUserObject();
                //episode = Controller.getInstance().removeEpisode(season, episode.getTitle());
                //Episode episode = Controller.getInstance().removeEpisode(season, episodeTitle);

                if(DataManager.INSTANCE.removeEpisode(season, episode.getTitle()) != null){ 
                    //remove episode from GUI 
                    this.removeLastNodeFromTree(this.getTreePath(episode, season, serie));                
                }
            } 
        }
    }
   
   @Override
   public void setSelectedValue(String partialName){
       // Search forward from first visible row looking for any visible node
       if(jTree1.getRowCount() > 0){
           TreePath matchTreePath = getNextMatch(partialName, 0, Position.Bias.Forward);
           if(matchTreePath != null){
               jTree1.setSelectionPath(matchTreePath);
               jTree1.scrollPathToVisible(matchTreePath);
           }
       }
   }
   
   public void setSelectedValue(Episode episode){
       TreePath matchTreePath = getTreePath(episode.getSeason().getSerie());
       if(matchTreePath != null){
           jTree1.expandPath(matchTreePath);
           matchTreePath = getTreePath(episode.getSeason(), episode.getSeason().getSerie());
           if(matchTreePath != null){
               jTree1.expandPath(matchTreePath);
               matchTreePath = getTreePath(episode, episode.getSeason(), episode.getSeason().getSerie());  
               if(matchTreePath != null){
                   jTree1.setSelectionPath(matchTreePath);
                   jTree1.scrollPathToVisible(matchTreePath);
               }
           }
       }
   }
   
   /**
     * Returns the TreePath to the next tree element that
     * contains the partialName. To handle the conversion of a
     * <code>TreePath</code> into a String, <code>convertValueToText</code>
     * is used.
     *
     * @param partialName the string to test for a match
     * @param startingRow the row for starting the search
     * @param bias the search direction, either
     * Position.Bias.Forward or Position.Bias.Backward.
     * @return the TreePath of the next tree element that
     * starts with the prefix; otherwise null
     * @exception IllegalArgumentException if prefix is null
     * or startingRow is out of bounds
     */
    private TreePath getNextMatch(String partialName, int startingRow,
                                 Position.Bias bias) {

        int max = jTree1.getRowCount();
        if (partialName == null) {
            throw new IllegalArgumentException();
        }
        if (startingRow < 0 || startingRow >= max) {
            throw new IllegalArgumentException();
        }
        partialName = partialName.toUpperCase();

        // start search from the next/previous element froom the
        // selected element
        int increment = (bias == Position.Bias.Forward) ? 1 : -1;
        int row = startingRow;
        do {
            TreePath path = jTree1.getPathForRow(row);
            String text = jTree1.convertValueToText(
                path.getLastPathComponent(), jTree1.isRowSelected(row),
                jTree1.isExpanded(row), true, row, false);

            if (text.toUpperCase().contains(partialName)) {
                return path;
            }
            row = (row + increment + max) % max;
        } while (row != startingRow);
        return null;
    }
   
   /**
    * Removes all values from the tree. <br/>
    * Inserts all collection elements in the tree. <br/>
    * This method will be performed asynchronly in another thread after all tasks in the EventDispatchThread.
   */
   @Override
   public void updateTabValues(){              
       if((collection != null) && (!collection.isEmpty())){
           Runnable actualizeGUI = new Runnable() {
               @Override
               public void run() {                   
                   //TreePath selectedPath = jTree1.getSelectionPath();
                   removeAllElements();
                   
                   //insert all elements
                    for(int i = 0; i < collection.size(); i ++){
                        update(null, collection.get(i));
                    }
                    //Selektiere alte Auswahl erneut
//                    jTree1.setSelectionPath(selectedPath);
//                    jTree1.scrollPathToVisible(selectedPath);
                }
            };
            SwingUtilities.invokeLater(actualizeGUI);                
       }
   }  
   
   /**
    * removes all elements from the tree
    */
   private void removeAllElements(){
       seriesRootTreeNode.removeAllChildren();
       seriesTreeModel.nodeStructureChanged(seriesRootTreeNode);
   }
   
    /**
    * Update an entry on the GUI
    *
    * @param serie the updated serie
    */
   public void updateSerieInGUI(Serie serie){        
       TreePath path = this.getTreePath(serie);
       //If the serie was not moved into another tab (i.e. path == null)
       if(path != null){
            TreeNode serieNode = (TreeNode)path.getPathComponent(1);
            int index = seriesRootTreeNode.getIndex(serieNode);
            this.removeLastNodeFromTree(path);  
            this.addSerieToGUI(serie,index);
       }
   }  
        
    /**
    * Returns the first matched treePath<br/>
    * 
    * @param serie the serie
    * @return the matched threePath <br/> null if no match was found
    */
   private TreePath getTreePath(final Serie serie){ 
       TreePath path = null;
       if(jTree1.getRowCount() > 0){
           int row;
           do{
               row = jTree1.getRowForPath(path) +1;
               path = jTree1.getNextMatch(serie.toString(), row, Position.Bias.Forward);
               
               if(path != null){
                    if(path.getPathCount() == 2){                  //it's a serie    
                        break;
                    }        
                    else if(row > jTree1.getRowForPath(path)){                           
                        path = null;     //search in tree completed 
                    }
               }
            }while (path != null);       
       }
       return path;
   } 
      
    /**
    * Returns the first matched treePath<br/>
    * 
    * @param season the season
    * @param serie the parent serie
    * 
    * @return the matched threePath <br/> null if no match was found
    */
   private TreePath getTreePath(final Season season, final Serie serie){ 
        TreePath path = null;
          if(jTree1.getRowCount() > 0){
            int row;
            do{
                row = jTree1.getRowForPath(path) +1;
                path = jTree1.getNextMatch(season.toString(), row, Position.Bias.Forward);
               
                if (path != null){
                    if((path.getPathCount() == 3) &&                                           //it's a season AND
                      (((DefaultMutableTreeNode)path.getPathComponent(1)).getUserObject().toString().equals(serie.toString()))){      //serie name is equal      
                        break;
                    }
                    else if(row > jTree1.getRowForPath(path)){                           
                        path = null;     //search in tree completed 
                    }       
                }
            }while (path != null);
        }
         return path;
   }  
   
    /**
    * Returns the first matched treePath<br/>null if no match was found
    * 
    * @param episode the episode
    * @param season the parent season
    * @param serie the parent serie
    * 
    * @return the matched threePath <br/> null if no match was found
    */
   private TreePath getTreePath(final Episode episode, final Season season, final Serie serie){       
       TreePath path = null;
       if(jTree1.getRowCount() > 0){
           int row;         
           do{              
               row = jTree1.getRowForPath(path) +1;
               path = jTree1.getNextMatch(episode.toString(), row, Position.Bias.Forward);
               
               if(path != null){
                    if((path.getPathCount() == 4) &&                                     //it's an episode AND
                      ((DefaultMutableTreeNode)path.getPathComponent(1)).getUserObject().toString().equals(serie.toString()) &&     //serie name is equal AND
                      ((DefaultMutableTreeNode)path.getPathComponent(2)).getUserObject().toString().equals(season.toString())){     //season name is equal
                        break;
                    }
                    else if(row > jTree1.getRowForPath(path)){                           
                        path = null;     //search in tree completed 
                    }
               }
           } while(path != null);
        }
        return path;      
   }   
   
   /**
    * Removes the last path node from the GUI <br/>
    * 
    * @param path the treepath where the last node should be removed
    */
   private void removeLastNodeFromTree(final TreePath path){
       if(path != null){  
            MutableTreeNode nodeToRemove = (MutableTreeNode)path.getLastPathComponent();
            // Remove node; if node has descendants, all descendants are removed as well
            seriesTreeModel.removeNodeFromParent(nodeToRemove);    
//       seriesTreeModel.nodeStructureChanged(seriesRootTreeNode);
       }
   }
   
   /**
    * Adds a new serie to the GUI <br/>
    * 
    * @param serie the serie to add
    */
   private void addSerieToGUI(final Serie serie){
       this.addSerieToGUI(serie, seriesRootTreeNode.getChildCount());
   }
   
      /**
    * Adds a new serie to the GUI <br/>
    * 
    * @param serie the serie to add
    */
   private synchronized void addSerieToGUI(final Serie serie, int index){
       DefaultMutableTreeNode serieTreeNodeToAdd = new DefaultMutableTreeNode(serie);
       serieTreeNodeToAdd.setAllowsChildren(true);    
       //add all seasons to the serie
       for(int i = 0; i < serie.getSeasons().size(); i ++){
           this.addSeasonToGUI(serieTreeNodeToAdd, serie.getSeason(i));
       }
       
       if(index <= seriesRootTreeNode.getChildCount()){      
           seriesTreeModel.insertNodeInto(serieTreeNodeToAdd, seriesRootTreeNode, index);
       }else{
           seriesTreeModel.insertNodeInto(serieTreeNodeToAdd, seriesRootTreeNode, seriesRootTreeNode.getChildCount());
       }
       jTree1.expandPath(new TreePath(seriesRootTreeNode));
//       seriesTreeModel.nodeStructureChanged(seriesRootTreeNode);
   }

   /**
    * Adds a new season to the GUI <br/>
    * 
    * @param treeNode the node to add the season
    * @param season the season to add
    */
   private void addSeasonToGUI(final DefaultMutableTreeNode treeNode, final Season season){       
       DefaultMutableTreeNode seasonNodeToAdd = new DefaultMutableTreeNode(season);
       seasonNodeToAdd.setAllowsChildren(true);    
       //add all episodes to the season
       for(int i = 0; i < season.getEpisodes().size(); i++){
           this.addEpisodeToGUI(seasonNodeToAdd, season.getEpisode(i));
       }
       treeNode.add(seasonNodeToAdd);
   }      
   
   /**
    * Adds a new episode to the GUI <br/>
    * 
    * @param treeNode the node to add the episode
    * @param episode the episode to add
    */
   private void addEpisodeToGUI(final DefaultMutableTreeNode treeNode, final Episode episode){       
       DefaultMutableTreeNode episodeNodeToAdd = new DefaultMutableTreeNode(episode);   
       episodeNodeToAdd.setAllowsChildren(false);   
       
       treeNode.add(episodeNodeToAdd);
   }   
     
   /**
   * Initialisiert Drop auf Windows
   * @see http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4899516
   */  
   private void initJListFileDropOnWindows(){
       DropTarget target = new DropTarget(jTree1, new DropTargetAdapter() {
           @Override
           public void drop(DropTargetDropEvent dtde) {
               if(dtde.isDataFlavorSupported(DataFlavor.javaFileListFlavor)){
                   dtde.acceptDrop(dtde.getDropAction());
                   try {
                       //siehe: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4899516
                       final List<File> list = (List<File>) dtde.getTransferable().getTransferData(DataFlavor.javaFileListFlavor);
                       //Hier steht der eigentliche Drop Code                       
                       if(CollectionManager.INSTANCE.isACollectionCreated()){            
                           //ImportGUI im extra Thread, damit durch den Import Prozess keine Verzögerungen auftreten                     
                           Runnable runImport = new Runnable() {
                               @Override
                               public void run() {
                                    ImportDirectoryGUI fileImport = new ImportDirectoryGUI(
                                            MovieManagerGUI.getInstance(), 
                                            true, 
                                            MovieManagerGUI.getInstance().getTabNames(),
                                            list,
                                            collection);
                                    fileImport.showGUI(); 
                               } 
                           };
                           SwingUtilities.invokeLater(runImport);
                       }
                   } 
                   catch (UnsupportedFlavorException | IOException ex) {
                       LOG.error("Error while dropping file into SeriesTree.", ex);
                   }                    
               }
           }
        });
        jTree1.setDropTarget(target);
   }   
   
   /**
    * @see JTree#clearSelection() 
    */   
    @Override
   public void clearSelection(){
       jTree1.clearSelection();
   }
   
   /**
    * Methode zum Anpassen der GUI an das neue Look and Feel
    **/
   @Override
   public void changeUI(){       
        jScrollPane2.setBorder(null); 
   }       
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JTree jTree1;
    // End of variables declaration//GEN-END:variables
}
